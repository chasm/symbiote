{"version":3,"file":"/packages/istanbul-middleware-port.js","sources":["istanbul-middleware-port/router_server.js","istanbul-middleware-port/router_common.js","istanbul-middleware-port/core.js","istanbul-middleware-port/zip-writer.js","istanbul-middleware-port/express-shim.js","istanbul-middleware-port/handlers.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,6B;;AAEA,iC;AACA,sD;AACA,Q;AACA,qC;AACA,C;;AAEA,sD;AACA,+C;AACA,Q;AACA,6C;AACA,C;;;AAGA,0B;AACA,sB;AACA,oB;AACA,yC;AACA,M;AACA,0B;AACA,E;;AAEA,0C;AACA,2D;AACA,oB;;AAEA,wC;AACA,uB;AACA,sB;AACA,K;;AAEA,iD;AACA,4C;AACA,kC;AACA,W;AACA,Y;AACA,yB;AACA,2E;AACA,8B;AACA,0B;AACA,S;AACA,uC;AACA,0D;AACA,S;AACA,8E;AACA,K;AACA,E;;AAEA,uD;AACA,mD;AACA,iD;;AAEA,kE;AACA,6E;;AAEA,0B;AACA,2C;AACA,+C;;AAEA,iD;AACA,S;AACA,K;;AAEA,iB;AACA,E;;AAEA,gD;AACA,sB;AACA,mG;AACA,K;;AAEA,kD;AACA,E;;AAEA,sC;AACA,oB;;AAEA,sB;AACA,4D;AACA,K;;AAEA,yB;;AAEA,0B;AACA,mB;AACA,iF;AACA,iE;AACA,uC;AACA,sE;AACA,qC;AACA,yE;;AAEA,8B;AACA,4D;;AAEA,uC;AACA,kC;AACA,wB;AACA,yE;;AAEA,mC;AACA,+E;AACA,4C;AACA,6E;AACA,iD;;AAEA,kD;AACA,iE;AACA,kE;AACA,0D;AACA,+B;AACA,yB;;AAEA,kD;AACA,4D;AACA,yB;;AAEA,2C;AACA,qB;;AAEA,6C;AACA,gD;AACA,oC;AACA,qB;;AAEA,2C;AACA,iB;AACA,qB;AACA,W;AACA,E;;AAEA,4B;AACA,+B;;;;;;;;;;;;;;;;;;ACrIA,a;AACA,8D;AACA,M;AACA,mE;AACA,M;AACA,O;AACA,oE;AACA,iD;AACA,M;AACA,e;AACA,M;AACA,sD;AACA,qE;AACA,M;AACA,2B;AACA,6B;AACA,+B;AACA,mB;AACA,O;;AAEA,4D;AACA,gC;AACA,yB;AACA,6B;AACA,uC;AACA,4B;AACA,+B;AACA,8B;AACA,K;;AAEA,O;AACA,sE;AACA,yB;AACA,M;AACA,2B;AACA,6B;AACA,4B;AACA,wB;AACA,mB;AACA,O;;AAEA,0E;AACA,uC;;AAEA,8E;;AAEA,yB;AACA,oC;AACA,4D;AACA,uC;;AAEA,6B;;AAEA,uD;AACA,kC;;AAEA,6C;AACA,0C;AACA,uB;;AAEA,sB;AACA,iE;AACA,sC;AACA,0B;AACA,oB;AACA,iC;AACA,a;AACA,S;;AAEA,oB;AACA,M;;AAEA,O;AACA,uC;AACA,sC;AACA,M;AACA,uC;AACA,yC;AACA,8C;AACA,2B;AACA,M;AACA,yC;AACA,2B;AACA,kC;AACA,+B;AACA,uB;AACA,mB;AACA,O;;AAEA,0D;AACA,gD;AACA,qE;AACA,mB;AACA,uC;AACA,qC;AACA,uC;AACA,gH;AACA,gE;AACA,oC;AACA,yB;AACA,6C;AACA,2B;AACA,6C;AACA,+F;AACA,uC;AACA,c;AACA,wC;AACA,yC;AACA,oC;;AAEA,kE;AACA,M;;AAEA,wB;;AAEA,oE;;AAEA,O;AACA,8E;AACA,iC;;AAEA,8E;;AAEA,4B;AACA,oE;AACA,mB;;AAEA,a;AACA,sD;AACA,mD;AACA,yB;AACA,O;AACA,yE;AACA,wB;AACA,6B;AACA,kB;AACA,6B;;AAEA,6E;AACA,sE;AACA,W;AACA,qD;;AAEA,gC;;AAEA,kE;AACA,2C;AACA,6C;AACA,oB;;AAEA,oC;AACA,mC;AACA,gB;AACA,8B;;AAEA,+C;AACA,U;;AAEA,uD;;AAEA,oB;AACA,K;AACA,K;;;;;;;;;;;;;;;;;;AClKA,E;AACA,sD;AACA,4F;AACA,G;AACA,uC;AACA,yB;AACA,6B;AACA,2B;AACA,yC;AACA,wB;AACA,6C;AACA,0B;;AAEA,U;;AAEA,4C;AACA,qC;AACA,2B;AACA,oD;AACA,+B;AACA,E;AACA,2C;;AAEA,wD;AACA,uD;AACA,oD;AACA,yB;AACA,+B;AACA,4B;AACA,uC;AACA,yB;AACA,S;AACA,2C;AACA,gD;AACA,M;AACA,C;;AAEA,kB;AACA,qB;AACA,e;AACA,mB;AACA,K;AACA,2C;AACA,C;AACA,G;AACA,sE;AACA,yE;AACA,uB;AACA,oE;AACA,W;AACA,G;AACA,6B;AACA,6C;AACA,qB;AACA,iD;AACA,4C;AACA,sC;AACA,sC;AACA,yC;AACA,yC;AACA,wC;AACA,c;AACA,S;AACA,K;AACA,C;AACA,G;AACA,sF;AACA,0B;AACA,G;AACA,oC;AACA,kC;AACA,qB;AACA,qB;AACA,2D;AACA,8C;AACA,wB;AACA,qC;AACA,mD;AACA,mD;AACA,mD;AACA,S;AACA,O;AACA,8C;AACA,qD;AACA,6B;AACA,S;AACA,O;AACA,E;AACA,G;AACA,gF;AACA,qB;AACA,iD;AACA,uG;AACA,+F;AACA,4C;AACA,G;AACA,kD;AACA,2B;AACA,kB;AACA,oB;AACA,qB;AACA,uB;;AAEA,sB;AACA,+D;;AAEA,qC;AACA,gE;AACA,uE;AACA,0C;AACA,c;AACA,U;AACA,K;AACA,6B;;AAEA,8C;AACA,kC;AACA,mD;AACA,kD;AACA,Y;AACA,iE;AACA,K;;AAEA,uB;AACA,e;AACA,sB;AACA,0C;AACA,iE;AACA,wE;;AAEA,8C;AACA,8B;AACA,uC;AACA,iC;AACA,+B;AACA,S;AACA,O;AACA,E;;AAEA,oC;AACA,0C;AACA,8C;AACA,4G;AACA,O;AACA,uC;AACA,C;;AAEA,kC;AACA,iB;;AAEA,2B;AACA,oC;AACA,gD;AACA,0B;AACA,W;AACA,K;;AAEA,6B;AACA,e;AACA,C;;AAEA,gD;AACA,yB;AACA,6C;AACA,oB;AACA,gB;AACA,mB;AACA,mB;AACA,e;AACA,qB;AACA,uC;;AAEA,0D;AACA,oD;AACA,qE;AACA,K;;AAEA,0B;AACA,mD;AACA,sB;AACA,K;;AAEA,sC;;AAEA,4B;AACA,4C;AACA,sC;;AAEA,uD;;AAEA,mC;;AAEA,sB;AACA,6B;AACA,uE;AACA,K;;AAEA,kB;AACA,kC;AACA,wD;AACA,U;AACA,qC;AACA,sC;AACA,U;AACA,wC;AACA,kB;AACA,0C;AACA,mC;AACA,a;AACA,sC;AACA,U;AACA,sC;AACA,4C;AACA,S;AACA,M;;AAEA,+D;AACA,+C;AACA,oC;AACA,+C;AACA,Y;AACA,uD;AACA,kD;AACA,8D;AACA,K;;AAEA,qB;AACA,E;;AAEA,2C;AACA,e;AACA,e;AACA,K;AACA,uC;AACA,kD;AACA,0C;AACA,kC;AACA,mB;AACA,uB;AACA,8D;AACA,gB;AACA,2B;AACA,S;AACA,oC;AACA,O;AACA,E;;;AAGA,oC;AACA,wB;AACA,E;;;;;;;;;;;;;;;;;;;;AC1PA,E;AACA,sD;AACA,4F;AACA,G;AACA,2B;;AAEA,0B;AACA,4B;AACA,oB;AACA,qB;AACA,2B;AACA,C;;AAEA,kB;AACA,uC;AACA,0D;AACA,yB;AACA,M;AACA,2B;AACA,8B;AACA,yB;AACA,M;AACA,4B;AACA,yB;AACA,mB;AACA,S;AACA,sC;AACA,iC;AACA,uC;AACA,a;AACA,mB;AACA,S;AACA,sC;AACA,0B;AACA,oG;AACA,M;AACA,0B;AACA,yB;AACA,yB;AACA,K;AACA,E;;AAEA,0C;AACA,oC;AACA,yB;AACA,0B;AACA,0B;AACA,E;;AAEA,uB;AACA,uC;AACA,2C;AACA,6C;AACA,W;AACA,M;AACA,0C;AACA,6D;AACA,sD;AACA,S;AACA,yB;AACA,uB;AACA,mB;AACA,M;AACA,6B;AACA,wB;AACA,yB;AACA,M;AACA,gC;AACA,oC;AACA,8B;AACA,M;AACA,2B;AACA,gC;AACA,M;AACA,sB;AACA,8D;AACA,M;AACA,uB;AACA,6B;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;AChFA,uB;AACA,0C;AACA,2D;AACA,+C;AACA,oC;AACA,mD;AACA,iD;AACA,c;AACA,uC;AACA,2D;AACA,oD;AACA,c;AACA,kD;AACA,wC;AACA,c;AACA,iD;AACA,W;AACA,K;;AAEA,Y;AACA,0B;AACA,U;AACA,wC;AACA,wC;AACA,U;AACA,yC;AACA,wC;AACA,S;AACA,M;AACA,E;;;;;;;;;;;;;;;;;;;;AC7BA,E;AACA,sD;AACA,4F;AACA,G;;AAEA,+B;AACA,2B;AACA,uC;AACA,sC;AACA,kD;AACA,6B;AACA,iC;AACA,6B;AACA,mC;AACA,2B;AACA,oB;;AAEA,qC;AACA,2B;AACA,wB;;AAEA,wB;;AAEA,8C;AACA,sC;AACA,0D;AACA,wC;AACA,qD;AACA,2B;AACA,S;AACA,wC;AACA,O;;AAEA,mE;AACA,0C;;AAEA,0D;AACA,4C;AACA,qC;AACA,yC;AACA,uB;AACA,gD;AACA,S;AACA,oB;AACA,wD;AACA,8D;AACA,S;AACA,wC;AACA,O;;AAEA,4C;AACA,mD;AACA,kE;AACA,S;;AAEA,+C;AACA,8C;AACA,iC;AACA,iC;AACA,S;;AAEA,mF;AACA,4B;AACA,2C;AACA,+B;AACA,+B;AACA,O;AACA,O;;AAEA,sD;AACA,4C;AACA,iD;AACA,O;;AAEA,iF;AACA,8C;AACA,oC;AACA,0D;AACA,4D;AACA,wC;AACA,oC;AACA,uB;AACA,kG;AACA,2E;AACA,c;;AAEA,gD;AACA,sC;;AAEA,6B;AACA,yD;AACA,kF;AACA,yB;AACA,wD;AACA,kE;AACA,W;AACA,2C;AACA,0C;AACA,W;AACA,sB;AACA,O;;AAEA,+C;AACA,6C;AACA,4B;;AAEA,qF;AACA,8F;AACA,S;AACA,uC;AACA,6B;AACA,O;;AAEA,e;AACA,E;;AAEA,oC;AACA,oC;AACA,2D;AACA,C;;AAEA,uC;AACA,2B;AACA,wC;AACA,uC;AACA,qD;AACA,6C;AACA,S;AACA,4C;AACA,M;AACA,C;;AAEA,wD;AACA,+B;;AAEA,sC;;AAEA,4B;AACA,0B;AACA,S;AACA,4C;AACA,wB;AACA,0B;AACA,S;;AAEA,sC;AACA,sH;AACA,0B;AACA,S;AACA,oC;AACA,6E;AACA,0B;AACA,S;AACA,gE;AACA,6B;AACA,sB;AACA,gE;AACA,8B;AACA,a;AACA,iB;AACA,yF;AACA,8B;AACA,mG;AACA,iB;AACA,wE;AACA,8C;AACA,0B;AACA,qE;AACA,8B;AACA,a;AACA,W;AACA,M;AACA,C;;AAEA,6C;AACA,sB;;AAEA,wB;AACA,uD;AACA,+E;AACA,gE;AACA,e;AACA,E;;AAEA,6B;;AAEA,gB","sourcesContent":["var connectHandlers, connect;\n\nif (typeof(Npm) == \"undefined\") {\n    connect = __meteor_bootstrap__.require(\"connect\");\n} else {\n    connect = Npm.require(\"connect\");\n}\n\nif (typeof __meteor_bootstrap__.app !== 'undefined') {\n    connectHandlers = __meteor_bootstrap__.app;\n} else {\n    connectHandlers = WebApp.connectHandlers;\n}\n\n\nvar RRouter = function() {\n    this._routes = [];\n    this._config = {\n        requestParser: connect.bodyParser\n    };\n    this._started = false;\n};\n\n// simply match this path to this function\nRRouter.prototype.add = function(path, method, endpoint)  {\n    var self = this;\n\n    // Start serving on first add() call\n    if(!this._started){\n        this._start();\n    }\n\n    if (_.isObject(path) && ! _.isRegExp(path)) {\n        _.each(path, function(endpoint, p) {\n            self.add(p, endpoint);\n        });\n    } else {\n        if (! endpoint) {\n            // no http method was supplied so 2nd parameter is the endpoint\n            endpoint = method;\n            method = null;\n        }\n        if (! _.isFunction(endpoint)) {\n            endpoint = _.bind(_.identity, null, endpoint);\n        }\n        self._routes.push([new Meteor.RRouter.Route(path, method), endpoint]);\n    }\n};\n\nRRouter.prototype.match = function(request, response) {\n    for (var i = 0; i < this._routes.length; i++) {\n        var params = [], route = this._routes[i];\n\n        if (route[0].match(request.url, request.method, params)) {\n            context = {request: request, response: response, params: params};\n\n            var args = [];\n            for (var key in context.params)\n                args.push(context.params[key]);\n\n            return route[1].apply(context, args);\n        }\n    }\n\n    return false;\n};\n\nRRouter.prototype.configure = function(config) {\n    if(this._started){\n        throw new Error(\"RRouter.configure() has to be called before first call to RRouter.add()\");\n    }\n\n    this._config = _.extend(this._config, config);\n};\n\nRRouter.prototype._start = function(){\n    var self = this;\n\n    if(this._started){\n        throw new Error(\"RRouter has already been started\");\n    }\n\n    this._started = true;\n\n    // hook up the serving\n    connectHandlers\n        .use(connect.query()) // <- XXX: we can probably assume accounts did this\n        .use(this._config.requestParser(this._config.bodyParser))\n        .use(function(req, res, next) {\n            // need to wrap in a fiber in case they do something async\n            // (e.g. in the database)\n            if(typeof(Fiber)==\"undefined\") Fiber = Npm.require('fibers');\n\n            Fiber(function() {\n                var output = Meteor.RRouter.match(req, res);\n\n                if (output === false) {\n                    return next();\n                } else {\n                    // parse out the various type of response we can have\n\n                    // array can be\n                    // [content], [status, content], [status, headers, content]\n                    if (_.isArray(output)) {\n                        // copy the array so we aren't actually modifying it!\n                        output = output.slice(0);\n\n                        if (output.length === 3) {\n                            var headers = output.splice(1, 1)[0];\n                            _.each(headers, function(value, key) {\n                                res.setHeader(key, value);\n                            });\n                        }\n\n                        if (output.length === 2) {\n                            res.statusCode = output.shift();\n                        }\n\n                        output = output[0];\n                    }\n\n                    if (_.isNumber(output)) {\n                        res.statusCode = output;\n                        output = '';\n                    }\n\n                    return res.end(output);\n                }\n            }).run();\n        });\n};\n\n// Make the router available\nMeteor.RRouter = new RRouter();","(function() {\n    // Route object taken from page.js, slightly stripped down\n    //\n    // Copyright (c) 2012 TJ Holowaychuk &lt;tj@vision-media.ca&gt;\n    //\n    /**\n     * Initialize `Route` with the given HTTP `path`, HTTP `method`,\n     * and an array of `callbacks` and `options`.\n     *\n     * Options:\n     *\n     *   - `sensitive`    enable case-sensitive routes\n     *   - `strict`       enable strict matching for trailing slashes\n     *\n     * @param {String} path\n     * @param {String} method\n     * @param {Object} options.\n     * @api private\n     */\n\n    Meteor.RRouter.Route = function(path, method, options) {\n        options = options || {};\n        this.path = path;\n        this.method = method;\n        this.regexp = pathtoRegexp(path\n            , this.keys = []\n            , options.sensitive\n            , options.strict);\n    }\n\n    /**\n     * Check if this route matches `path` and optional `method`, if so\n     * populate `params`.\n     *\n     * @param {String} path\n     * @param {String} method\n     * @param {Array} params\n     * @return {Boolean}\n     * @api private\n     */\n\n    Meteor.RRouter.Route.prototype.match = function(path, method, params){\n        var keys, qsIndex, pathname, m;\n\n        if (this.method && this.method.toUpperCase() !== method) return false;\n\n        keys = this.keys;\n        qsIndex = path.indexOf('?');\n        pathname = ~qsIndex ? path.slice(0, qsIndex) : path;\n        m = this.regexp.exec(pathname);\n\n        if (!m) return false;\n\n        for (var i = 1, len = m.length; i < len; ++i) {\n            var key = keys[i - 1];\n\n            var val = 'string' == typeof m[i]\n                ? decodeURIComponent(m[i])\n                : m[i];\n\n            if (key) {\n                params[key.name] = undefined !== params[key.name]\n                    ? params[key.name]\n                    : val;\n            } else {\n                params.push(val);\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Normalize the given path string,\n     * returning a regular expression.\n     *\n     * An empty array should be passed,\n     * which will contain the placeholder\n     * key names. For example \"/user/:id\" will\n     * then contain [\"id\"].\n     *\n     * @param  {String|RegExp|Array} path\n     * @param  {Array} keys\n     * @param  {Boolean} sensitive\n     * @param  {Boolean} strict\n     * @return {RegExp}\n     * @api private\n     */\n\n    function pathtoRegexp(path, keys, sensitive, strict) {\n        if (path instanceof RegExp) return path;\n        if (path instanceof Array) path = '(' + path.join('|') + ')';\n        path = path\n            .concat(strict ? '' : '/?')\n            .replace(/\\/\\(/g, '(?:/')\n            .replace(/\\+/g, '__plus__')\n            .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function(_, slash, format, key, capture, optional){\n                keys.push({ name: key, optional: !! optional });\n                slash = slash || '';\n                return ''\n                    + (optional ? '' : slash)\n                    + '(?:'\n                    + (optional ? slash : '')\n                    + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n                    + (optional || '');\n            })\n            .replace(/([\\/.])/g, '\\\\$1')\n            .replace(/__plus__/g, '(.+)')\n            .replace(/\\*/g, '(.*)');\n\n        return new RegExp('^' + path + '$', sensitive ? '' : 'i');\n    };\n\n    /// END Route object\n\n    // Added by tom, lifted from mini-pages, with some modifications\n\n    /**\n     Given a context object, returns a url path with the values of the context\n     object mapped over the path.\n\n     Alternatively, supply the named parts of the paths as discrete arguments.\n\n     @method pathWithContext\n     @param [context] {Object} An optional context object to use for\n     interpolation.\n\n     @example\n     // given a page with a path of \"/posts/:_id/edit\"\n     var path = page.pathWithContext({ _id: 123 });\n     // > /posts/123/edit\n     */\n    Meteor.RRouter.Route.prototype.pathWithContext = function (context) {\n        var self = this,\n            path = self.path,\n            parts,\n            args = arguments;\n\n        /* get an array of keys from the path to replace with context values.\n         /* XXX Right now this comes from page-js. Remove dependency. \n         */\n        parts = self.regexp.exec(self.path).slice(1);\n\n        context = context || {};\n\n        var replacePathPartWithContextValue = function (part, i) {\n            var re = new RegExp(part, \"g\"),\n                prop = part.replace(\":\", \"\"),\n                val;\n\n            if (_.isObject(context))\n                val = context[prop]\n            else\n                val = args[i];\n\n            path = path.replace(re, val || '');\n        };\n\n        _.each(parts, replacePathPartWithContextValue);\n\n        return path;\n    }\n}());","/*\n Copyright (c) 2013, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar istanbul = Npm.require('istanbul'),\n    hook = istanbul.hook,\n    Report = istanbul.Report,\n    utils = istanbul.utils,\n    Instrumenter = istanbul.Instrumenter,\n    instrumenter = null,\n    TreeSummarizer = istanbul.TreeSummarizer,\n    baselineCoverage = {};\n\ncore = {};\n\n//single place to get global coverage object\nvar getCoverageObject = function () {\n    /*jslint nomen: true */\n    global.__coverage__ = global.__coverage__ || {};\n    return global.__coverage__;\n};\ncore.getCoverageObject = getCoverageObject;\n\n//returns a matcher that returns all JS files under root\n//except when the file is anywhere under `node_modules`\n//does not use istanbul.matcherFor() so as to expose\n//a synchronous interface\nfunction getRootMatcher(root) {\n    return function (file) {\n        if (file.indexOf(root) !== 0) {\n            return false;\n        }\n        file = file.substring(root.length);\n        return file.indexOf('node_modules') < 0;\n    };\n}\n\n//deep-copy object\nfunction clone(obj) {\n    if (!obj) {\n        return obj;\n    }\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n * save the baseline coverage stats for a file. This baseline is not 0\n * because of mainline code that is covered as part of loading the module\n * @method saveBaseline\n * @param file the file for which baseline stats need to be tracked.\n * @private\n */\nfunction saveBaseline(file) {\n    var coverageObject = getCoverageObject(),\n        fileCoverage;\n    if (coverageObject && coverageObject[file]) {\n        fileCoverage = coverageObject[file];\n        if (!baselineCoverage[file]) {\n            baselineCoverage[file] = {\n                s: clone(fileCoverage.s),\n                f: clone(fileCoverage.f),\n                b: clone(fileCoverage.b)\n            };\n        }\n    }\n}\n/**\n * overwrites the coverage stats for the global coverage object to restore to baseline\n * @method restoreBaseline\n */\ncore.restoreBaseline = function () {\n    var cov = getCoverageObject(),\n        fileCoverage,\n        fileBaseline;\n    Object.keys(baselineCoverage).forEach(function (file) {\n        fileBaseline = baselineCoverage[file];\n        if (cov[file]) {\n            fileCoverage = cov[file];\n            fileCoverage.s = clone(fileBaseline.s);\n            fileCoverage.f = clone(fileBaseline.f);\n            fileCoverage.b = clone(fileBaseline.b);\n        }\n    });\n    Object.keys(cov).forEach(function (file) {\n        if (!baselineCoverage[file]) { //throw it out\n            delete cov[file];\n        }\n    });\n};\n/**\n * hooks `require` to add instrumentation to matching files loaded on the server\n * @method hookLoader\n * @param {Function|String} matcherOrRoot one of:\n *      a match function with signature `fn(file)` that returns true if `file` needs to be instrumented\n *      a root path under which all JS files except those under `node_modules` are instrumented\n * @param {Object} opts instrumenter options\n */\ncore.hookLoader = function (matcherOrRoot, opts) {\n    /*jslint nomen: true */\n    var matcherFn,\n        transformer,\n        postLoadHook,\n        postLoadHookFn;\n\n    opts = opts || {};\n    opts.coverageVariable = '__coverage__'; //force this always\n\n    postLoadHook = opts.postLoadHook;\n    if (!(postLoadHook && typeof postLoadHook === 'function')) {\n        postLoadHook = function (/* matcher, transformer, verbose */) {\n            return function (/* file */) {\n            };\n        };\n    }\n    delete opts.postLoadHook;\n\n    if (typeof matcherOrRoot === 'function') {\n        matcherFn = matcherOrRoot;\n    } else if (typeof matcherOrRoot === 'string') {\n        matcherFn = getRootMatcher(matcherOrRoot);\n    } else {\n        throw new Error('Argument was not a function or string');\n    }\n\n    if (instrumenter) {\n        return;\n    } //already hooked\n    instrumenter = new Instrumenter(opts);\n    transformer = instrumenter.instrumentSync.bind(instrumenter);\n    postLoadHookFn = postLoadHook(matcherFn, transformer, opts.verbose);\n\n    hook.hookRequire(matcherFn, transformer, {\n        verbose: opts.verbose,\n        postLoadHook: function (file) {\n            postLoadHookFn(file);\n            saveBaseline(file);\n        }\n    });\n};\n\nfunction getTreeSummary(collector) {\n    var summarizer = new TreeSummarizer();\n    collector.files().forEach(function (key) {\n        summarizer.addFileCoverageSummary(key, utils.summarizeFileCoverage(collector.fileCoverageFor(key)));\n    });\n    return summarizer.getTreeSummary();\n}\n\nfunction getPathMap(treeSummary) {\n    var ret = {};\n\n    function walker(node) {\n        ret[node.fullPath()] = node;\n        node.children.forEach(function (child) {\n            walker(child);\n        });\n    }\n\n    walker(treeSummary.root);\n    return ret;\n}\n\ncore.render = function (filePath, res, prefix) {\n    prefix = '/coverage';\n    var collector = new istanbul.Collector(),\n        treeSummary,\n        pathMap,\n        linkMapper,\n        outputNode,\n        report,\n        fileCoverage,\n        coverage = getCoverageObject();\n\n    if (!(coverage && Object.keys(coverage).length > 0)) {\n        res.setHeader('Content-type', 'text/plain');\n        return res.end('No coverage information has been collected');\n    }\n\n    prefix = prefix || '';\n    if (prefix.charAt(prefix.length - 1) !== '/') {\n        prefix += '/';\n    }\n\n    utils.removeDerivedInfo(coverage);\n\n    collector.add(coverage);\n    treeSummary = getTreeSummary(collector);\n    pathMap = getPathMap(treeSummary);\n\n    filePath = filePath || treeSummary.root.fullPath();\n\n    outputNode = pathMap[filePath];\n\n    if (!outputNode) {\n        res.statusCode = 404;\n        return res.end('No coverage for file path [' + filePath + ']');\n    }\n\n    linkMapper = {\n        hrefFor: function (node) {\n            return prefix + 'show?p=' + node.fullPath();\n        },\n        fromParent: function (node) {\n            return this.hrefFor(node);\n        },\n        ancestor: function (node, num) {\n            var i;\n            for (i = 0; i < num; i += 1) {\n                node = node.parent;\n            }\n            return this.hrefFor(node);\n        },\n        asset: function (node, name) {\n            return prefix + 'asset/' + name;\n        }\n    };\n\n    report = Report.create('html', { linkMapper: linkMapper });\n    res.setHeader('Content-type', 'text/html');\n    if (outputNode.kind === 'dir') {\n        report.writeIndexPage(res, outputNode);\n    } else {\n        fileCoverage = coverage[outputNode.fullPath()];\n        utils.addDerivedInfoForFile(fileCoverage);\n        report.writeDetailPage(res, outputNode, fileCoverage);\n    }\n\n    return res.end();\n};\n\ncore.mergeClientCoverage = function (obj) {\n    if (!obj) {\n        return;\n    }\n    var coverage = getCoverageObject();\n    Object.keys(obj).forEach(function (filePath) {\n        var original = coverage[filePath],\n            added = obj[filePath],\n            result;\n        if (original) {\n            result = utils.mergeFileCoverage(original, added);\n        } else {\n            result = added;\n        }\n        coverage[filePath] = result;\n    });\n};\n\n\ncore.getInstrumenter = function () {\n    return instrumenter;\n};\n\n","/*\n Copyright (c) 2013, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar fs = Npm.require('fs');\n\nfunction Sync(zipStream) {\n    this.stream = zipStream;\n    this.queue = [];\n    this.idle = true;\n    this.finalized = false;\n}\n\nSync.prototype = {\n    addFile: function (content, file) {\n        this.queue.push({ file: file, content: content });\n        this.maybeSync();\n    },\n    finalize: function () {\n        this.finalized = true;\n        this.maybeSync();\n    },\n    maybeSync: function () {\n        if (!this.idle) {\n            return;\n        }\n        if (this.queue.length === 0) {\n            if (this.finalized) {\n                this.stream.finalize();\n            }\n            return;\n        }\n        var item = this.queue.shift();\n        this.idle = false;\n        this.stream.addFile(item.content, { name: item.file, store: true}, this.handler.bind(this));\n    },\n    handler: function () {\n        this.idle = true;\n        this.maybeSync();\n    }\n};\n\nZipWriter = function (zipStream, prefix) {\n    this.sync = new Sync(zipStream);\n    this.prefix = prefix;\n    this.currentFile = '';\n    this.currentData = '';\n};\n\nZipWriter.prototype = {\n    copyFile: function (source, dest) {\n        this.writeFile(dest, function (w) {\n            w.write(fs.readFileSync(source));\n        });\n    },\n    writeFile: function (file, callback) {\n        if (this.prefix && file.indexOf(this.prefix) === 0) {\n            file = file.substring(this.prefix.length);\n        }\n        this.start(file);\n        callback(this);\n        this.end();\n    },\n    println: function (str) {\n        this.write(str);\n        this.write('\\n');\n    },\n    start: function (fileName) {\n        this.currentFile = fileName;\n        this.currentData = '';\n    },\n    write: function (str) {\n        this.currentData += str;\n    },\n    end: function () {\n        this.sync.addFile(this.currentData, this.currentFile);\n    },\n    done: function () {\n        this.sync.finalize();\n    }\n};","express = function () {\n    function createRoute(route, handler) {\n        route = '/coverage' + (route === '/' ? '' : route);\n        Meteor.RRouter.add(route, function () {\n            var res = this.response;\n            res.setHeader = function (key, value) {\n                res.writeHead(200, {key: value});\n            };\n            res.json = function (obj) {\n                res.setHeader('Content-type', 'text/json');\n                return res.end(JSON.stringify(obj));\n            };\n            res.send = function (error, message) {\n                return res.end(message);\n            };\n            handler(this.request, this.response);\n        });\n    }\n\n    return {\n        use: function () {\n        },\n        get: function (route, handler) {\n            createRoute(route, handler);\n        },\n        post: function (route, handler) {\n            createRoute(route, handler);\n        }\n    };\n};\n\n","/*\n Copyright (c) 2013, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = Npm.require('path'),\n    fs = Npm.require('fs'),\n    istanbul = Npm.require('istanbul'),\n//    ASSETS_DIR = istanbul.assetsDir,\n    existsSync = fs.existsSync || path.existsSync,\n    url = Npm.require('url'),\n    zs = Npm.require('archiver'),\n    Report = istanbul.Report,\n    Collector = istanbul.Collector,\n    utils = istanbul.utils,\n    JS_RE = /\\.js$/;\n\ncreateHandler = function (/*opts*/) {\n    /*jslint nomen: true */\n//    opts = opts || {};\n\n    var app = express();\n\n    //show main page for coverage report for /\n    app.get('/', function (req, res) {\n        var origUrl = url.parse(req.originalUrl).pathname,\n            origLength = origUrl.length;\n        if (origUrl.charAt(origLength - 1) !== '/') {\n            origUrl += '/';\n        }\n        core.render(null, res, origUrl);\n    });\n\n    //show page for specific file/ dir for /show?file=/path/to/file\n    app.get('/show', function (req, res) {\n\n        var origUrl = url.parse(req.originalUrl).pathname,\n            u = url.parse(req.url).pathname,\n            pos = origUrl.indexOf(u),\n            file = req.url.substring(17);\n        if (pos >= 0) {\n            origUrl = origUrl.substring(0, pos);\n        }\n        if (!file) {\n            res.setHeader('Content-type', 'text/plain');\n            return res.end('[p] parameter must be specified');\n        }\n        core.render(file, res, origUrl);\n    });\n\n//    send static file for /asset/asset-name\n//    app.get('/asset/:name', function (req, res) {\n//        res.sendfile(path.resolve(ASSETS_DIR, req.params.name));\n//    });\n\n    //reset coverage to baseline on POST /reset\n//    app.post('/reset', function (req, res) {\n//        core.restoreBaseline();\n//        res.json({ ok: true });\n//    });\n\n    //opt-in to allow resets on GET as well (useful for easy browser-based demos :)\n//    if (opts.resetOnGet) {\n    app.get('/reset', function (req, res) {\n        core.restoreBaseline();\n        res.json({ ok: true });\n    });\n//    }\n\n    //return global coverage object on /object as JSON\n    app.get('/object', function (req, res) {\n        res.json(core.getCoverageObject() || {});\n    });\n\n    //send self-contained download package with coverage and reports on /download\n    app.get('/download', function (req, res) {\n        var stream = zs.createZip(),\n            writer = new ZipWriter(stream, process.cwd()),\n            coverageObject = core.getCoverageObject() || {},\n            collector = new Collector(),\n            baseDir = process.cwd(),\n            reports = [\n                Report.create('html', { writer: writer, dir: path.join(baseDir, 'lcov-report') }),\n                Report.create('lcovonly', { writer: writer, dir: baseDir })\n            ];\n\n        utils.removeDerivedInfo(coverageObject);\n        collector.add(coverageObject);\n\n        res.statusCode = 200;\n        res.setHeader('Content-type', 'application/zip');\n        res.setHeader('Content-Disposition', 'attachment; filename=coverage.zip');\n        stream.pipe(res);\n        writer.writeFile('coverage.json', function (w) {\n            w.write(JSON.stringify(coverageObject, undefined, 4));\n        });\n        reports.forEach(function (report) {\n            report.writeReport(collector);\n        });\n        writer.done();\n    });\n\n    //merge client coverage posted from browser\n    app.post('/client', function (req, res) {\n        var body = req.body;\n\n        if (!(body && typeof body === 'object')) { //probably needs to be more robust\n            return res.send(400, 'Please post an object with content-type: application/json');\n        }\n        core.mergeClientCoverage(body);\n        res.json({ok: true});\n    });\n\n    return app;\n};\n\nfunction defaultClientMatcher(req) {\n    var parsed = url.parse(req.url);\n    return parsed.pathname && parsed.pathname.match(JS_RE);\n}\n\nfunction defaultPathTransformer(root) {\n    return function (req) {\n        var parsed = url.parse(req.url),\n            pathName = parsed.pathname;\n        if (pathName && pathName.charAt(0) === '/') {\n            pathName = pathName.substring(1);\n        }\n        return path.resolve(root, pathName);\n    };\n}\n\nfunction clientHandler(matcher, pathTransformer, opts) {\n    var verbose = opts.verbose;\n\n    return function (req, res, next) {\n\n        if (!matcher(req)) {\n            return next();\n        }\n        var fullPath = pathTransformer(req);\n        if (!fullPath) {\n            return next();\n        }\n\n        if (!core.getInstrumenter()) {\n            console.error('No instrumenter set up, please call createHandler() before you use the client middleware');\n            return next();\n        }\n        if (!existsSync(fullPath)) {\n            console.warn('Could not find file [' + fullPath + '], ignoring');\n            return next();\n        }\n        fs.readFile(fullPath, 'utf8', function (err, contents) {\n            var instrumented;\n            if (err) {\n                console.warn('Error reading file: ' + fullPath);\n                return next();\n            }\n            try {\n                instrumented = core.getInstrumenter().instrumentSync(contents, fullPath);\n                if (verbose) {\n                    console.log('Sending instrumented code for: ' + fullPath + ', url:' + req.url);\n                }\n                res.setHeader('Content-type', 'application/javascript');\n                return res.send(instrumented);\n            } catch (ex) {\n                console.warn('Error instrumenting file:' + fullPath);\n                return next();\n            }\n        });\n    };\n}\n\ncreateClientHandler = function (root, opts) {\n    opts = opts || {};\n\n    var app = express(),\n        matcher = opts.matcher || defaultClientMatcher,\n        pathTransformer = opts.pathTransformer || defaultPathTransformer(root);\n    app.get('*', clientHandler(matcher, pathTransformer, opts));\n    return app;\n};\n\nhookLoader = core.hookLoader;\n\ncreateHandler();\n"]}